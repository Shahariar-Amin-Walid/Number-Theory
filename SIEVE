আজ আমি প্রাইম সংখ্যা যাচাইয়ের উপায় নিয়ে লিখব।আগেই বলে রাখি আমি মোটেও দক্ষ কোডার না।মাত্র কয়েকমাস হল আমি আমার যাত্রা শুরু করেছি।এই লিখার উদ্দেশ্য নিজে শেখা।
যে সকল সংখ্যাকে ১ এবং ওই সংখ্যা ব্যাতীত অন্য সংখ্যা দিয়ে ভাগ করা যায় না সে সকল সংখ্যাই প্রাইম।কোনো সংখ্যা n প্রাইম হবে যদি ওই সংখ্যাকে 1 এবং n ছাড়া অন্য সংখ্যা দিয়ে ভাগ 
করলে তা নিঃশেষে বিভাজ্য না হয়।অর্থাৎ n প্রাইম কি না তা জানার জন্য আমাদের n-2 টি সংখ্যা দিয়ে ভাগ করাই যঠেষ্ট।
কোনো সংখ্যা প্রাইম কি না তা জানার ফাংশন ...
n প্রাইম হলে ১ রিটান করবে,নন-প্রাইম হলে ০;
int  isPrime(int n)
{
      if(n==0) return 0;
      else if(n==1) return 0;
      for(int i=2;i<n;i++)
              if(n % i == 0) 
                     return 0;
      return 1;
}
প্রতিটা ভাগ করতে যে সময় লাগবে তা ধ্রুবক।ধরি এই সময় 1 সেকেন্ড।মোট n-2 টি ভাগ করতে সময় লাগবে n-2 সেকেন্ড। অর্থাৎ এই ফাংশনের টাইম কমপ্লেক্সিটি O(n).একটু চালাক না হলে কি চলে!!!
প্রাইম সংখ্যা গুলার মধ্যে ২ কেবলমাত্র ইভেন।বাকি সব প্রাইমই ওড(বিজোড়)।এই হিসাব অনুযায়ী কোড করতে পারলে আমাদের অপারেশন সংখ্যা হবে (n-2)/2;
কোডঃ
int  isPrime(int n)
{
      if(n==0) return 0;
      if(n==1) return 0;
      if(n==2) return 1;
      for(int i=3;i<n;i+=2)
              if(n % i == 0) 
                     return 0;
      return 1;
}
আসলেই কি আমরা কোনো লাভ করতে পারলাম!!!হিসাব করে দেখা যাবে,এবারও আমাদের টাইম কমপ্লেক্সজিটি O(n).অর্থাৎ অপারেশন সংখ্যা অর্ধেক করা হলেও কমপ্লেক্সিটি আগের মতোই আছে!!!
আমাদের আসল উদ্দেশ্য হল কমপ্লেক্সিটি কমানো।
ধরি আমরা n প্রাইম কি না তা যাচাই করতে চাচ্ছি।
ধরি n = p x q
এখন p ও q এর সম্ভাব্য মান বিবেচনা করি...
১।উভয়ই sqrt(n) এর ছোট।
২। উভয়ই sqrt(n) এর বড়।
৩।একটি সংখ্যা sqrt(n) এর ছোট অন্যটি বড়।
১ ও ২ নম্বার অবশ্যই ভুল।
তাই বলা যায় কোন সংখ্যা n এর দুইটা  উৎপাদকের একটা অবশ্যই sqrt(n) এর ছোট।
নতুন কোডঃ
int  isPrime(int n)
{
      if(n==0) return 0;
      if(n==1) return 0;
      for(int i=2;i*i <= n;i++)
              if(n % i == 0) 
                     return 0;
      return 1;
}
প্রিসিশন ইরর এড়ানোর জন্য আমরা i<=sqrt(n) না লিখে i*i <= n লিখেছি।আমরা আমাদের প্রগ্রামের কমপ্লেক্সিটি কমিয়ে আনতে পারছি!!!এখন কমপ্লেক্সিটি  O(sqrt(n)).
আমরা চাইলেই কমপ্লেক্সিটি আরও কমাইয়ে আনতে পারি।এই অ্যালগোরিদমের নাম হবে সীভ অফ ইরাটোসথেন্স।ধরা যাক আমরা ১-১০০ পর্যন্ত সংখ্যা গুলোর মধ্যে প্রাইম গুলা আলাদা করব।তারপর সেই তালিকা 
থেকে ১ টি করে সংখ্যা তুলবো আর সেই সংখ্যার সব গুণিতককে কেটে দিব।মানে আমরা আগে যে কাজ করেছি এখন তার অপজিট কাজ করব।বিস্তারিত জানতে
https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
কোডঃ
void seive( int n )
{
//create a boolean array named prime[n+1].value of prime[i] will be false if i is //not prime else true.
bool prime[n+1];
memset(prime,true,sizeof(prime));
for(int i = 2;i*i<=n;i++){
      if(prime[i]==true){
           for(int j=i*i;j<=n;j+=i)
                       prime[j] = false;
               }
         }
}
এই অ্যালগোরিদমের কমপ্লেক্সিটি O(nloglogn).
                                                                                              শাহারিয়ার আমিন
                                                                                              রুয়েট,সি.এস.ই.-১৯।
